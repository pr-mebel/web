# .gitlab-ci.yml
# Pipeline for building and deploying a Next.js application to a VPS
# Assumes:
# - Runner tagged 'vps-deploy' exists on the target VPS.
# - Runner uses the 'shell' executor and runs as the deployment user (e.g., 'web').
# - Deployment user has passwordless sudo rights for specific pm2 commands.
# - Required GitLab CI/CD variables are set (see below).

stages:
  - build
  - deploy

# Cache node_modules and Next.js build cache between jobs/pipelines
cache:
  key: ${CI_COMMIT_REF_SLUG} # Cache per branch
  paths:
    - .next/cache/
    - node_modules/
  policy: pull-push # Pull at start, push at end if changed

build_app:
  stage: build
  image: node:22 # Use an appropriate Node.js LTS version
  script:
    - echo "Starting build process..."
    - echo "Node version: $(node -v), npm version: $(npm -v)"
    - echo "Installing dependencies..."
    # Use 'npm ci' for faster, cleaner installs using package-lock.json
    - npm ci
    - echo "Building Next.js application..."
    # This will use next.config.js settings (e.g., ignoreDuringBuilds)
    - npm run build
    - echo "Build complete."
    # Optional: Remove development dependencies if node_modules is artifacted
    # npm prune --production
  artifacts:
    paths:
      # Include build output, runtime dependencies, config, and public assets
      - .next/
      - public/
      - package.json
      - package-lock.json
      - next.config.js
      # Include ecosystem file if you use one for PM2
      # - ecosystem.config.js
    exclude:
      # Exclude build cache from artifacts if already cached separately
      - .next/cache/
    expire_in: 1 hour # Keep artifacts for deploy job

deploy_app:
  stage: deploy
  tags:
    - vps-deploy # Ensures this job runs on your VPS runner
  environment:
    name: production
    url: https://pr-mebel.ru # Replace with your actual domain
  script:
    - echo "Deploying application to VPS..."
    - echo "Running as user: $(whoami)"
    - echo "Deploying to: ${DEPLOY_PATH}"
    - echo "Navigating to deployment directory..."
    - cd ${DEPLOY_PATH}

    # --- Environment Variable Setup ---
    - echo "Creating .env.production.local file..."
    - echo "# Auto-generated by GitLab CI/CD on $(date)" > .env.production.local
    # --- Add YOUR specific environment variables here ---
    # Read values from GitLab CI/CD variables defined in project settings
    - echo "CONTENTFUL_ACCESS_TOKEN=${CONTENTFUL_ACCESS_TOKEN}" >> .env.production.local
    - echo "CONTENTFUL_SPACE_ID=${CONTENTFUL_SPACE_ID}" >> .env.production.local
    - echo "CONTENTFUL_URI=${CONTENTFUL_URI}" >> .env.production.local
    - echo "EMAIL_MAIL_RU=${EMAIL_MAIL_RU}" >> .env.production.local
    - echo "NEXT_PUBLIC_POSTHOG_HOST=${NEXT_PUBLIC_POSTHOG_HOST}" >> .env.production.local
    - echo "NEXT_PUBLIC_POSTHOG_KEY=${NEXT_PUBLIC_POSTHOG_KEY}" >> .env.production.local
    - echo "PASSWORD_MAIL_RU=${PASSWORD_MAIL_RU}" >> .env.production.local
    - echo "ROISTAT_KEY=${ROISTAT_KEY}" >> .env.production.local
    # --- End of your specific variables ---
    - echo "Setting permissions for .env file..."
    - chmod 600 .env.production.local
    - echo ".env file created."

    - echo "Installing production dependencies on server..."
    - npm ci --only=production
    - echo "Dependencies installed."

    # --- Application Restart ---
    - echo "Reloading application '${APP_NAME}' with PM2..."
    # Use the full path to pm2 defined in variables for reliability
    # Use 'reload' for zero-downtime, fall back to 'restart' if reload fails or app doesn't support it
    # This requires the deployment user to have passwordless sudo for these specific commands
    - sudo ${PM2_PATH} reload ${APP_NAME} || sudo ${PM2_PATH} restart ${APP_NAME}
    - echo "PM2 reload/restart command executed."
    - echo "Deployment finished successfully!"
  only:
    # Only run this deploy job on pushes/merges to the main branch
    - main # Or master, or your production branch name
